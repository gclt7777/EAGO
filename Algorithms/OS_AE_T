function OS_AE_T(Global)
% <algorithm> <L>
% OS_AE_T : Objective-space Grouping + AE(PCA) + Linear T write-back
%
% 我们的风格要点：
% - 目标聚类 → 唯一指派变量列 S_k（用 T 子块能量）
% - 组内：PCA 潜空间 + DE(rand/1/bin) 生成新的目标向量
% - 写回：仅改各自 S_k 列，半步融合 eta，避免串扰
% - T 为 zscore 域的岭回归 SVD 解；支持 EMA 平滑
% - periodGroup：重分组/重指派周期；tPeriod：T 的拟合周期（独立于分组）
%
% 例： main('-algorithm',@OS_AE_T,'-problem',@DTLZ2,'-M',10,'-D',500,'-N',276,'-evaluation',1e5);

    %% 参数
    %  K,topFrac,lambda,eta,kcap,kfrac,F,Cr,periodGroup,emaA,tPeriod
    [K,topFrac,lambda,eta,kcap,kfrac,F,Cr,periodGroup,emaA,tPeriod] = ...
        Global.ParameterSet(3,0.2,1e-5,0.5,4,1/3,0.7,0.9,5,0.0,1);

    %% 初始化
    Population = Global.Initialization();
    gen = 1; map_prev = [];

    % 首次：分组 + 指派 + 拟合 T
    [O_groups,S_groups,map] = group_and_assign_map(Population,K,topFrac,lambda);
    if emaA>0, map_prev = map; end

    %% 主循环
    while Global.NotTermination(Population)
        X = Population.decs;   % N×D
        Y = Population.objs;   % N×M
        OffDec = X;

        % —— 节奏控制：分组/指派 与 T 拟合（互相独立） ——
        doReGroup = (gen==1) || (mod(gen-1,periodGroup)==0);
        doFitT    = (gen==1) || (mod(gen-1,tPeriod)==0);

        if doReGroup
            [O_groups,S_groups,map_new0] = group_and_assign_map(Population,K,topFrac,lambda);
        elseif doFitT
            map_new0 = fitMap_ridgeSVD(Y,X,lambda);
        else
            map_new0 = map; % 本代不变
        end

        % —— 仅对 T 做 EMA 平滑（统计量用最新） ——
        if doFitT
            if emaA>0 && ~isempty(map_prev)
                map_blend.T   = (1-emaA)*map_prev.T + emaA*map_new0.T;
                map_blend.muY = map_new0.muY;  map_blend.sigY = map_new0.sigY;
                map_blend.muX = map_new0.muX;  map_blend.sigX = map_new0.sigX;
                map = map_blend; map_prev = map_blend;
            else
                map = map_new0;  map_prev = map_new0;
            end
        end

        % —— 分组：PCA→DE 生成，并用子块 T(Ok,Sk) 写回各自列 ——
        for k = 1:numel(O_groups)
            Ok = O_groups{k};  Sk = S_groups{k};
            if isempty(Ok) || isempty(Sk), continue; end

            Yk      = Y(:,Ok);
            Yk_new  = ae_pca_generate(Yk,kcap,kfrac,F,Cr);      % N×|Ok|
            Xhat_Sk = apply_map_sub(map,Yk_new,Ok,Sk);           % 反标准化写回
            OffDec(:,Sk) = (1-eta)*OffDec(:,Sk) + eta*Xhat_Sk;   % 半步融合
        end

        % 边界裁剪 + 评估 + 环境选择（保留我们常用的“非支配+角度截断”）
        OffDec    = min(max(OffDec,Global.lower),Global.upper);
        Offspring = INDIVIDUAL(OffDec);
        Population = env_select_local([Population,Offspring], Global.N);

        gen = gen + 1;
    end
end

%% ============ 分组/指派/映射 ============

function [O_groups,S_groups,map] = group_and_assign_map(Population,K,topFrac,lambda)
X = Population.decs; Y = Population.objs;
[~,D] = size(X);  M = size(Y,2);

% K 钳制
if isempty(K) || ~isscalar(K) || K<1, K = min(3,M); end
if M==1, K_eff=1; else, K_eff = min(K, max(1,M-1)); end

% 目标聚类：优先外部 OS_GroupByObjective（若不可用则内置）
try
    [Og,~,~] = OS_GroupByObjective(Population,'K',K_eff);
    O_groups = Og;
catch
    O_groups = os_group_by_objective_builtin(Y,K_eff);
end

% 拟合 zscore 域 T，并存统计量用于反标准化写回
map = fitMap_ridgeSVD(Y,X,lambda);

% 唯一指派 + 组内取 topFrac
Keff = numel(O_groups);
energy = zeros(Keff,D);
for k = 1:Keff
    Ok = O_groups{k}; if isempty(Ok), continue; end
    Tk = map.T(Ok,:);                    % |Ok|×D
    energy(k,:) = sqrt(sum(Tk.^2,1));    % 子块能量
end
[~,owner] = max(energy,[],1);

S_groups = cell(1,Keff);
for k = 1:Keff
    idx = find(owner==k);
    if isempty(idx), S_groups{k} = []; continue; end
    e = energy(k,idx); [~,ord] = sort(e,'descend');
    topK = max(1, round(topFrac*numel(idx)));
    S_groups{k} = idx(ord(1:topK));
end
end

function map = fitMap_ridgeSVD(Y,X,lambda)
% 在标准化域解 T，并保存反标准化所需统计量
muY = mean(Y,1);  sigY = std(Y,0,1); sigY(sigY==0)=1;
muX = mean(X,1);  sigX = std(X,0,1); sigX(sigX==0)=1;

Yz = (Y - muY)./sigY;
[U,S,V] = svd(Yz,'econ'); sig = diag(S);
G  = V * diag(sig./(sig.^2 + lambda)) * U';   % (Y'Y+λI)^{-1}Y'
Xz = (X - muX)./sigX;
T  = G * Xz;                                   % M×D

map.T=T; map.muY=muY; map.sigY=sigY; map.muX=muX; map.sigX=sigX;
end

function O_groups = os_group_by_objective_builtin(Y,K)
[~,M] = size(Y);
if M==1 || K<=1, O_groups = {1:M}; return; end
K = min(K, max(1,M-1));

Yz = zscore(Y,0,1);
Yz(~isfinite(Yz)) = 0;               % 轻量防护
nrm = sqrt(sum(Yz.^2,1)); nrm(nrm==0)=1;
U = Yz ./ nrm;
S = U.'*U; S(1:M+1:end)=0;

A = max(S,0); A = A - diag(diag(A));
d = sum(A,2); Dm = diag(d + eps);
Lsym = eye(M) - Dm^(-1/2)*A*Dm^(-1/2); Lsym = (Lsym+Lsym.')/2;

[V,E] = eig(Lsym);
[~,ord] = sort(diag(E),'ascend');
H  = V(:,ord(1:K));
Hn = H ./ max(sqrt(sum(H.^2,2)),eps); Hn(~isfinite(Hn))=0;

try
    opts = statset('MaxIter',200,'Display','off');
    repl = max(5, min(10, M-1));
    lbl  = kmeans(Hn,K,'Replicates',repl,'Options',opts);
catch
    % 无统计工具箱时的兜底：按顺序均匀分配
    idx = 1:M; lbl = mod(idx-1,K)+1;
end
O_groups = cell(1,K);
for k = 1:K, O_groups{k} = find(lbl==k).'; end
end

%% ============ 目标侧 AE(PCA) + DE(rand/1/bin) ============

function Y_new = ae_pca_generate(Yk,kcap,kfrac,F,Cr)
[Ykz,mu,sg] = safe_zscore(Yk);
r  = max(1, min([size(Yk,2), max(1, ceil(size(Yk,2)*kfrac)), kcap]));
W  = pca_basis(Ykz,r);
Z  = Ykz * W;

% 一步 DE(rand/1/bin) 于潜空间
[N,k] = size(Z); Znew = Z;
if N>=4 && k>0
    idx = 1:N;
    for i=1:N
        rset = idx; rset(i)=[];
        rset = rset(randperm(numel(rset),3));
        v = Z(rset(1),:) + F*(Z(rset(2),:)-Z(rset(3),:));
        jrand = randi(k);
        mask = (rand(1,k) < Cr); mask(jrand) = true;
        u = Z(i,:); u(mask) = v(mask);
        Znew(i,:) = u;
    end
end
Y_new = (Znew * W') .* sg + mu;
end

function [Z,mu,sg] = safe_zscore(X)
mu = mean(X,1);
sg = std(X,0,1); sg(sg==0)=1;
Z  = (X - mu) ./ sg;
end

function W = pca_basis(X,k)
[~,~,V] = svd(X,'econ'); W = V(:,1:k);
end

%% ============ 写回（子块映射 + 反标准化） ============

function Xhat_Sk = apply_map_sub(map,Yk_new,Ok,Sk)
Yz  = bsxfun(@rdivide, bsxfun(@minus, Yk_new, map.muY(Ok)), map.sigY(Ok));
Xz  = Yz * map.T(Ok,Sk);
Xhat_Sk = bsxfun(@plus, bsxfun(@times, Xz, map.sigX(Sk)), map.muX(Sk));
end

%% ============ 环境选择：非支配 + 角度截断 ============

function Population = env_select_local(Population,N)
PopObj = Population.objs;
[FrontNo, MaxFNo] = NDSort(PopObj, N);
Next = FrontNo < MaxFNo;
Last = find(FrontNo == MaxFNo);
K = N - sum(Next);
if K > 0
    Choose = truncation_angle(PopObj(Last,:), K);
    Next(Last(Choose)) = true;
end
Population = Population(Next);
end

function Choose = truncation_angle(PopObj,K)
fmax = max(PopObj,[],1); fmin = min(PopObj,[],1);
span = fmax - fmin; span(span==0) = 1;
P = (PopObj - fmin) ./ span;
nrm = sqrt(sum(P.^2,2)); nrm(nrm==0)=1; U = P ./ nrm;
Cosine = U*U.'; Cosine(1:size(Cosine,1)+1:end)=0;

Choose = false(1,size(P,1));
[~,extreme] = max(P,[],1); Choose(extreme)=true;

if sum(Choose) > K
    sel = find(Choose); Choose=false(1,size(P,1));
    Choose(sel(randperm(numel(sel),K))) = true;
else
    while sum(Choose) < K
        unSel = find(~Choose);
        [~,x] = min(max(Cosine(~Choose,Choose),[],2));
        Choose(unSel(x)) = true;
    end
end
end
